# Redis 高可用

## 主从

### 工作机制

* salver 启动后，向master发送SYNC，master收到命令后，通过bgsave生成RDB快照，同时在缓冲区记录这段时间的写命令。
* master将RDB发送给slaver
* salver加载快照
* master将缓冲区中的命令发送给slaver
* slaver接受并执行，完成同步
* 每当master收到写命令，会将命令同步到slaver

### 优点

* 读写分离，提高读性能，分担master读压力
* 同步时非阻塞的，同步期间，master仍能提供服务

### 缺点

* 没有故障转移，master下线后需要手动切换或等待恢复
* 不能动态扩容，容量受限于单机master
* 如果同步没有完成，手动切换IP后可能存在数据不一致

## 哨兵

引入哨兵监控与处理故障

### 工作机制

* sentinel 与master建立两条连接（自动发现slaver） 订阅连接与命令连接 获取节点信息与其他的监控sentinel
* sentinel 与其他sentinel 建立命令连接
* 定期检测连接
* 如果发现超时，认为主观下线，询问其他哨兵，如果超过一定数目，认为客观下线
* 选举领头哨兵进行故障回复（Raft）
* 从故障的master的从节点当选新的master 根据优先级，复制偏移量

### 优点

* 比主从多了故障转移

### 缺点

* 不能扩容
* 需要sentinel集群，增添了复杂性

## 集群

### 工作机制

* 集群的每个节点上分配slots 0~16383
* 存取key的时候根据CRC(key)找到对应的slot
* 从集群中获取值，如果当前节点不存在相应的slot,返回REMOVED，重新查找
* 如果超过半数的节点认为某个节点fail,启动其从节点为主节点

### 优点

* 去中心架构，每个节点保存其他所有节点信息
* 动态扩容
* 故障转移

### 缺点

* 不支持多个数据库
* 无法使用事务
* 批量操作限制
* 客户端实现复杂
* 数据迁移，同步操作，当key过大时，会导致集群内部故障转移，造成不必要的切换

## 总结

主从：主节点Down后需要手动指定新的从节点为主节点，基本不用

哨兵：数据量不多，规模不大，需要容错的时候使用

集群：数据量大，QPS高的时候用